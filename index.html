<!DOCTYPE html>
<html>
<head>
    <title>Framework PHP - Campus Ynov - Mars 2017</title>
    <meta charset="utf-8">
    <style>
        @import url(lato-font.min.css);
        @import url(roboto-slab.css);

        body {
            font-family: 'Lato', sans-serif;
        }
        h1, h2, h3 {
            font-family: 'Roboto Slab';
            font-weight: normal;
            color: rgb(232, 72, 106);
        }
        .center.middle h1 {
            margin-bottom: 38px;
        }
        h1 {
            color: rgb(43, 178, 211);
            margin-bottom: 0;
        }
        h2, h3 {
            margin: 0;
        }
        .remark-slide-content {
            padding-top: 0;
            padding-left: 50px;
            padding-right: 50px;
            font-size: 30px;
        }
        p, ul {
            margin-top: 0;
        }
        a {
            color: rgb(232, 72, 106);
        }
    </style>
</head>
<body>
    <textarea id="source">

class: center, middle

# Framework PHP
## Campus Ynov - Mars 2017

---

# Présentation

- [@killianblais](https://twitter.com/killianblais) | [github.com/kblais](https://github.com/kblais)
- Développeur Backend chez [Startup Palace](https://www.startup-palace.com) :
    - Développeur Laravel depuis 3 ans (depuis Laravel 4.1)
    - Animateur du sujet qualité au sein de toute l'équipe de développement

.center[![](img/sp.gif)]

---

# Qu'est-ce qu'un framework ?

> Un framework [...] désigne un ensemble cohérent de composants logiciels structurels, qui sert à créer les fondations ainsi que les grandes lignes de tout ou d’une partie d'un logiciel (architecture).

Définition d'après [Wikipedia](https://fr.wikipedia.org/wiki/Framework)

- Ensemble de bibliothèques
- Générique (dans la limite des possibilités du langage)
- Cadre facilitant/guidant le travail du développeur

???

- Générique : le framework ne va pas vous limiter dans ce wue vous souhaitez faire

---

# Les frameworks en PHP

## Les principaux

- Zend Framework :
    - créé par un des développeurs de PHP en 2006 ([Zeev Suraski](https://twitter.com/zeevs))
    - utilisé dans Magento
- Symfony :
    - créé par [Fabien Potentier](https://twitter.com/fabpot) en 2005
    - maintenu par SensioLabs
- Laravel :
    - framework PHP moderne le plus jeune (2011)
- CodeIgniter
- CakePHP

???

- Zend :
    - lourd / usine à gaz
    - actuellement en version 3.0 (depuis juin 2016)
- Symfony :
    - SensioLabs société française
    - Le framework s'exporte aux US
    - Aujourd'hui utilisé par le CMS Drupal dans sa dernière version
- Laravel :
    - Jeune mais a beaucoup évolué depuis ses débuts
- CodeIgniter et CakePHP :
    - Inspirés de Ruby on Rails
    - 2006 et 2005

---

# Les frameworks en PHP

## Les moins connus

- Phalcon
- Yii

## Alternatives full API

- Lumen (Laravel)
- Silex (Symfony)
- Slim

???

- Phalcon :
    - librairie en C donnant accès à plus d'API
- Full API :
    - optimisé pour de hautes performances avec de nombreux appels HTTP par seconde
    - frameworks légers ("micro-framework")
- Lumen :
    - composants de Laravel sans le système de vue et l'ORM (activables)
- Silex :
    - composants de Symfony
    - l'un des plus performants
- Slim :
    - micro-framework le plus performant

---

# Les frameworks en PHP

## Pourquoi autant de choix ?

- Langage web [le plus utilisé](https://w3techs.com/) :
    - 82,5% de part de marché
    - Utilisé par des tenors du web: Wikipedia, Facebook, etc...
- Le langage est très flexible, et vous laisse faire n'importe quoi
- Les besoins ont beaucoup évolué depuis les début de PHP

???

- Facebook :
    - a créé un fork de PHP: HHVM (Hip Hop Virtual Machine) :
        - compilation JiT
        - compile le code PHP en bytecode (entre le code PHP et le code exécutable par la machine)
    - a créé un langage étendant PHP: Hack
- Flexibilité :
    - les variables globales = se tirer une balle dans le pied
- Besoins :
    - à l'origine, PHP était un langage de templating
    - devenu bien plus complexe :
        - bases de données
        - services externes
        - etc...

---

# Laravel - Présentation

- Langage créé par [Taylor Otwell](https://twitter.com/taylorotwell) en 2011
- Framework MVC moderne :
    - compatible avec les dernières versions de PHP (PHP 7.1)
    - mis à jour régulièrement
- Écosystème de plus en plus large
- Ressources nombreuses :
    - [Documentation](https://www.laravel.com/docs/5.4)
    - [Laracasts](http://laracasts.com/): vidéos présentant Laravel ainsi que des sujets transverses (du JS avec VueJS, etc...)
    - [Laravel News](https://laravel-news.com/)
    - [Github](https://github.com/laravel/framework/): les tickets sont une énorme source d'information
- Forte croissance

???

- conçu autour de composants de Symfony (le routeur, l'invite de commande, ) et d'autres librairies opensource :
    - Monolog : gestion des logs
    - Flysystem : gestion du système de fichiers
    - Carbon : améliore la gestion des objets DateTime
    - etc...
- mises à jour :
    - une version mineure tous les 6 mois (nouvelles fonctionnalités)
    - versions patch régulières pour fix certaines bugs
- MVC: Model View Controller ;
- Écosystème :
    - Homestead : box Vagrant pour faciliter le développement
    - Valet : application pour MacOS pour mettre en place un env de dev simplement
    - Cashier : librairie simplifiant la mise en place de Stripe dans une application laravel
    - Envoy : exécution de tâches sur des serveurs distants
    - Passport : serveur OAuth2
    - Scout : simplification de la recherche fulltext (adapter pour Elasticsearch, Algolia, ...)
    - Socialite : simplifie l'intégration de connexion via Facebook, Twitter, Github, etc...

---

# Généralités sur MVC

- `M` pour Model :
    - abstraction de la base de données ou d'un service externe
- V pour View :
    - comment l'information est affichée
    - correspond à la fois à un affichage dans une page web ou dans une API
- C pour Controller :
    - composé d'actions
    - récupére des données du modèles et les confier à la vue
    - récupére les données d'une requête et les confier au modèle pour enregistrement

???

- action :
    - méthode appellée par le routeur dans un controller

---

# Laravel - Installation

- Installation via [Composer](https://getcompoer.org) :
    - Installation: voir https://getcomposer.org/download/
- Une fois Composer installé :

    ```bash
    $ composer create-project laravel/laravel
    ```

- Pour lancer l'application :

    ```bash
    $ php artisan serve
    ```

???

- Composer : gestionnaire de dépendances de PHP

---

# Laravel - Flux d'une requête

- Le routeur donne la route utilisée
- Si des middlewares sont associés à la route, on les applique sur la requête
- Renvoie vers le bon couple controlleur + action : `app/Http/Controllers`
    - on applique les règles de validation si demandé
    - on applique l'action sur la requête, et on renvoie le résultat

???

- Routes : fichiers `routes/*.php` + `RouteServiceProvider.php`
- Middleware : `app\Http\Kernel.php` + routes
- Validation : uniquement si un des paramètre de l'action étend une `FormRequest`

---

# Laravel - L'arborescence

- `app` : dossier contenant toute la logique de la l'application
- `bootstrap` : scripts permettant à l'application de se démarrer
- `config` : configuration de l'application et des différents packages
- `database` : contient les migrations et seeders
- `public` : point d'entrée de l'application
- `resources` : ressources annexes pour l'application
- `routes` : définition des routes de l'application
- `storage` : stockage des fichiers privés de l'application
- `tests` : classes de tests
- `vendor` : dépendances PHP installées par Composer

???

- `app` : on y reviendra plus tard
- `config` :
    - chaque configuration est accessible depuis n'importe où dans Laravel
- `database` :
    - migrations: scripts créant les tables de base de données
    - seeders: scripts créant des données de test ou des données nécessaires au fonctionnement de l'application
- `public` :
    - unique fichier d'entrée `index.php` qui initialise l'application
    - stockage de tous les fichiers publics (assets, avatars, fichier uploadés, etc...)
- `resources` :
    - `assets` : fichiers SCSS/JS non compilés/minifiés
    - `lang` : fichiers de traduction
    - `views` : fichiers des vues de l'application
- `routes` :
    - on y reviendra plus tard
- `tests` :
    - depuis récemment, tests séparés entre tests fonctionnels et tests unitaires

---

# Laravel - L'arborescence

- `.env` : variables de configuration de l'application
- `artisan` : outil en ligne de commande de Laravel
- `composer.json` : fichier définissant les dépendances de Laravel
- `package.json` : dépendances npm
- `phpunit.xml` : fichier de configuration de PHPUnit
- `server.php` : lance l'application directement depuis la ligne de commande (sans configuration Apache/Nginx)
- `webpack.mix.js` : fichier de configuration de [Mix](https://laravel.com/docs/5.4/mix)

???

- `.env` :
    - équivalent à la définition de variables d'environnement sur la machine où est hébergé l'application
- `artisan` : très très utile pour le workflow de développement
- `composer.json` (et `composer.lock`):
    - définit également :
        - nom de l'application
        - license
        - des scripts pour Composer
        - des config spécifique pour Composer (version de PHP pour les dépendances, etc...)
    - le `.lock` contient les dépendances installées au dernier `composer update`
    - la différence entre `install` et `update`
- `package.json` :
    - Laravel vient préinstallé avec un certain nombre de dépendances front, dont le framework JS VueJS et Bootstrap-sass
- `phpunit.xml` :
    - définition de variables d'environnement spécifiques pour les tests unitaires, etc...
- `webpack.mix.js` :
    - Mix est une surcouche à Webpack
    - permet de compiler le javascript et le sass en 2 fichiers

---

# Laravel - `app`

Après une installation, le dossier `app` est assez vide:

- `Console` :
    - contient toutes nos définitions de commandes pour Artisan
- `Exceptions` :
    - contient la configuration de l'intercepteur d'exceptions
    - contient les exceptions de l'application
- `Http` :
    - `Controllers` : contient nos controlleurs
    - `Middleware` : contient nos middleware
- `Providers` :
    - configuration à plus haut niveau

???

- Au fur et à mesure des besoins, les dossiers se crééent via l'outil de ligne de commande `artisan`
- `Console` :
    - les commandes seront dans un dossier `Commands`
- `Exceptions` :
    - `Handler.php` liste les exceptions levées par Laravel que l'on ne souhaite pas faire remonter dans les logs
- `Http` :
    - middleware:
        - "script" venant se placer entre l'entrée dans l'application et dans le routeur, et le controller censé gérer la requête
        - gestion des middlewares dans le fichier `app/Http/Kernel.php`
        - certains middleware sont activés par défaut
- `Providers` :
    - exemples: modification des différents fichiers de routes, ajout de bindings pour les routes...

---

# Laravel - `app`

- Le dossier `app` contient également les modèles de l'application.
    - Une classe `Model` est une abstraction d'une table de base de données
    - Utilisation de l'ORM Eloquent
        - syntaxe fluide

        ```php
        Article::where('published_at', '>=', Carbon::now())
            ->where('archived_at', null)
            ->get();
        ```

        - renvoie un objet `Collection` qui donne de nombreuses possibilités dans la manipulation des données

???

- Permet de récupérer les lignes de la table `articles` publiés (`published_at` >= à la date d'aujourd'hui) et non archivés

---

# Laravel - Routeur, controlleur et action

Dans notre fichier de route `routes/web.php` :

```php
Route::get('hello', function () {
    return 'Hello world';
});
```

???

- Objectif :
    - créer une route `/hello`
    - en sortie : "Hello World"
- Solution artisanale, la logique n'est pas séparée des routes qui ne devraient être que déclaratives.
- On va utiliser un controlleur.

---

# Laravel - Routeur, controlleur et action

- Pour créer un nouveau controlleur :

    ```bash
    $ php artisan make:controller PageController
    # Pour créer un controlleur RESTful
    $ php artisan make:controller -r PageController
    ```

???

- Controlleur RESTful :
    - les méthodes correspondent aux différents verbes HTTP : GET, POST, PUT/PATCH, DELETE

---

# Laravel - Routeur, controlleur et action

- On créé une nouvelle méthode à notre controlleur :

    ```php
    public function hello()
    {
        return 'Hello World';
    }
    ```

- On ajoute une nouvelle route qui pointe vers cette action :

    ```php
    Route::get('hello', 'PageController@hello');
    ```

???

- Ajout de la route dans `routes/web.php`

---

# Laravel - Routeur, controlleur et action

## Bonne pratique : les routes nommées

- Nommer la route avec un identifiant unique dans l'application.

    ```php
    Route::get('hello', [
        'uses' => 'PageController@hello',
        'as' => 'page.hello',
    ]);
    ```

???

- Utilité :
    - aucune URL en dur dans le code
    - en cas de changement du schéma des URL (`on ne veut plus /article mais /nos-actualites`), uniquement besoin de
    changer la route

---

# Laravel - Routeur, controlleur et action

```php
public function hello()
{
    return <<<EOT
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Hello World - Campus Ynov - Mars 2017</title>
</head>
<body>
    <h1>Hello world</h1>
</body>
</html>
EOT;
}
```

---

# Laravel - Les vues

- Situées dans le dossier `resources/views`
- Langage de templating de Laravel : [Blade](https://laravel.com/docs/5.4/blade)
- Pour faire appel à un fichier `resources/views/hello.blade.php`, on utilise :

    ```php
    view('hello');
    ```

- Dans notre méthode :

    ```php
    public function hello()
    {
        return view('hello');
    }
    ```

---

# Laravel - Les vues

Fichier `resources/views/hello.blade.php` :

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Hello World - Campus Ynov - Mars 2017</title>
</head>
<body>
    <h1>Hello world</h1>
</body>
</html>
```

---

# Laravel - Les vues

- Pour se simplifier la vie, on va utiliser un layout pour nos vues
    - contient les parties communes à toutes nos pages
- Le layout (`resources/views/layout.blade.php`) :

    ```html
    <html>
    <head>
        <title>@yield('title') - Campus Ynov - Mars 2017</title>
    </head>
    <body>
        @yield('content')
    </body>
    </html>
    ```

---

# Laravel - Les vues

- Notre vue :

    ```html
    @extends('layout')



    @section('content')
        <h1>Hello world</h1>
    @endsection
    ```

---

# Laravel - Les modèles

- Un modèle Eloquent <=> une table en base :
    - Par défaut le nom de la table est le nom de la classe passé en "snake_case", et au pluriel
    - Exemple :
        - `Article` <=> `articles`
        - `ArticleCategory` <=> `article_categories`
- Créer un modèle dans Laravel :

    ```bash
    $ php artisan make:model Article
    # Créer le modèle avec son fichier de migration basique
    $ php artisan make:model -m Article
    ```

- On peut surcharger le nom de la table en modifiant l'attribut `$table` du modèle

---

# Laravel - Les modèles

- `$fillable` : tableau listant les attributs "remplissables" via ces méthodes:

    ```php
    $article = new Article($attributes);
    Article::create($attributes);
    $article->fill($attributes);
    ```

- `$visible` : tableau listant les attributs du modèle visibles dans une sortie JSON
- Ces deux attributs ont également leurs inverses `$guarded` et `$hidden`

???

- Donner des exemples de données qu'on ne souhaite pas voir une sortie JSON

---

# Laravel - Les migrations

- Deux méthodes :
    - `up` : qu'est-ce qui est fait lorsqu'on créé notre base ?
    - `down` : qu'est-ce qui est fait lorsqu'on souhaite revenir à l'étape précédente ?
- De nombreux helpers :
    - `$table->increments('id')` : `INT(11) UNSIGNED AUTO-INCREMENT`
    - `$table->timestamps()` : deux colonnes datetime `created_at` et `updated_at`
    - `$table->string('title')` : `VARCHAR(255)`

???

- `up` : créer une table, y ajouter des colonnes, des index, etc...
- `down` : supprimer la table créée, annuler l'ajout de colonnes, etc...
- helpers :
    - `timestamps()` : géré nativement, désactivable dans le modèle
    - `string()` : possibilité de donner la taille du varchar en second paramètre


    </textarea>
    <script src="remark.min.js"></script>
    <script>
      var slideshow = remark.create({
        highlightStyle: 'monokai-sublime',
      });
  </script>
</body>
</html>
